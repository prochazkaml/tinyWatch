use crate::oled::Oled;

pub trait Chargen {
	fn width(c: u8) -> u8;
	fn height() -> u8;
	fn kerning() -> u8;
	fn draw(oled: &mut Oled, c: u8, x: u8, y: u8) -> u8;

	fn string_width(s: &[u8]) -> u8 {
		s.iter()
			.map(|c| Self::width(*c) + 1)
			.sum::<u8>()
			.saturating_sub(1) // Remove the trailing space
	}

	fn draw_string(oled: &mut Oled, s: &[u8], x: u8, y: u8) -> u8 {
		let mut width = 0;

		for c in s {
			width += Self::draw(oled, *c, x + width, y) + Self::kerning();
		}

		width.saturating_sub(Self::kerning()) // Remove the trailing space
	}

	fn draw_string_centered(oled: &mut Oled, s: &[u8], y: u8) -> u8 {
		Self::draw_string_centered_around(oled, s, 64, y)
	}

	fn draw_string_centered_around(oled: &mut Oled, s: &[u8], x: u8, y: u8) -> u8 {
		Self::draw_string(oled, s, x.saturating_sub(Self::string_width(s) / 2), y)
	}
}

pub struct SmallFont {}

impl SmallFont {
	const FONT_DATA: &[u8] = &[
		// Character lengths

		0x31, 0x35, 0x53,
		0x13, 0x22, 0x55,
		0x23, 0x13, 0x43,
		0x44, 0x44, 0x44,
		0x44, 0x11, 0x33,
		0x34, 0x54, 0x44,
		0x44, 0x44, 0x41,
		0x44, 0x45, 0x44,
		0x44, 0x44, 0x34,
		0x55, 0x55, 0x43,
		0x53, 0x34, 0x25,
		0x44, 0x44, 0x34,
		0x41, 0x34, 0x25,
		0x44, 0x44, 0x44,
		0x34, 0x55, 0x54,
		0x43, 0x13, 0x40,

		// Actual character data
		
		0x00, 0x00, 0x00, //  
		0x5F,  // !
		0x03, 0x00, 0x03,    // "
		0x14, 0x7F, 0x14, 0x7F, 0x14,      // #
		0x24, 0x4A, 0xFF, 0x4A, 0x34,      // $
		0x61, 0x1C, 0x43,    // %

		0x00,  // &
		0x02, 0x05, 0x02,    // '
		0x3E, 0x41,   // (
		0x41, 0x3E,   // )
		0x14, 0x08, 0x1C, 0x08, 0x14,      // *
		0x08, 0x08, 0x3E, 0x08, 0x08,      // +

		0x80, 0x40,   // ,
		0x08, 0x08, 0x08,    // -
		0x40,  // .
		0x60, 0x1C, 0x03,    // /
		0x3E, 0x41, 0x41, 0x3E,     // 0
		0x42, 0x7F, 0x40,    // 1

		0x62, 0x51, 0x49, 0x46,     // 2
		0x22, 0x49, 0x49, 0x36,     // 3
		0x18, 0x14, 0x12, 0x7F,     // 4
		0x4F, 0x49, 0x49, 0x31,     // 5
		0x3E, 0x49, 0x49, 0x32,     // 6
		0x01, 0x71, 0x09, 0x07,     // 7

		0x36, 0x49, 0x49, 0x36,     // 8
		0x26, 0x49, 0x49, 0x3E,     // 9
		0x28,  // :
		0xC8,  // ;
		0x08, 0x14, 0x22,    // <
		0x14, 0x14, 0x14,    // =

		0x22, 0x14, 0x08,    // >
		0x02, 0x51, 0x09, 0x06,     // ?
		0x3E, 0x59, 0x59, 0x59, 0x46,      // @
		0x7E, 0x11, 0x11, 0x7E,     // A
		0x7F, 0x49, 0x49, 0x36,     // B
		0x3E, 0x41, 0x41, 0x22,     // C

		0x7F, 0x41, 0x41, 0x3E,     // D
		0x7F, 0x49, 0x49, 0x41,     // E
		0x7F, 0x09, 0x09, 0x01,     // F
		0x3E, 0x41, 0x49, 0x3A,     // G
		0x7F, 0x08, 0x08, 0x7F,     // H
		0x7F,  // I

		0x21, 0x41, 0x41, 0x3F,     // J
		0x7F, 0x08, 0x14, 0x63,     // K
		0x7F, 0x40, 0x40, 0x40,     // L
		0x7F, 0x02, 0x1C, 0x02, 0x7F,      // M
		0x7F, 0x02, 0x04, 0x7F,     // N
		0x3E, 0x41, 0x41, 0x3E,     // O

		0x7F, 0x11, 0x11, 0x0E,     // P
		0x3E, 0x41, 0xC1, 0xBE,     // Q
		0x7F, 0x11, 0x11, 0x6E,     // R
		0x26, 0x49, 0x49, 0x32,     // S
		0x01, 0x7F, 0x01,    // T
		0x3F, 0x40, 0x40, 0x3F,     // U

		0x07, 0x18, 0x60, 0x18, 0x07,      // V
		0x1F, 0x60, 0x18, 0x60, 0x1F,      // W
		0x63, 0x14, 0x08, 0x14, 0x63,      // X
		0x03, 0x0C, 0x70, 0x0C, 0x03,      // Y
		0x71, 0x49, 0x45, 0x43,     // Z
		0x7F, 0x41, 0x41,    // [

		0x02, 0x04, 0x08, 0x10, 0x20,      // BackSlash
		0x41, 0x41, 0x7F,    // ]
		0x02, 0x01, 0x02,    // ^
		0x80, 0x80, 0x80, 0x80,     // _
		0x01, 0x02,   // `
		0x20, 0x54, 0x54, 0x38, 0x40,      // a

		0x3F, 0x48, 0x44, 0x38,     // b
		0x38, 0x44, 0x44, 0x28,     // c
		0x38, 0x44, 0x44, 0x7F,     // d
		0x38, 0x54, 0x54, 0x18,     // e
		0x08, 0x7E, 0x09,    // f
		0x98, 0xA4, 0xA4, 0x58,     // g

		0x7F, 0x04, 0x04, 0x78,     // h
		0x7D,  // i
		0x80, 0x80, 0x7D,    // j
		0x7F, 0x10, 0x28, 0x44,     // k
		0x3F, 0x40,   // l
		0x78, 0x04, 0x18, 0x04, 0x78,      // m

		0x7C, 0x04, 0x04, 0x78,     // n
		0x38, 0x44, 0x44, 0x38,     // o
		0xFC, 0x24, 0x24, 0x18,     // p
		0x18, 0x24, 0x24, 0xFC,     // q
		0x7C, 0x08, 0x04, 0x04,     // r
		0x48, 0x54, 0x54, 0x24,     // s

		0x04, 0x3F, 0x44,    // t
		0x3C, 0x40, 0x40, 0x7C,     // u
		0x1C, 0x20, 0x40, 0x20, 0x1C,      // v
		0x1C, 0x60, 0x18, 0x60, 0x1C,      // w
		0x44, 0x28, 0x10, 0x28, 0x44,      // x
		0x9C, 0xA0, 0xA0, 0x7C,     // y

		0x64, 0x54, 0x54, 0x4C,     // z
		0x08, 0x36, 0x41,    // {
		0x7F,  // |
		0x41, 0x36, 0x08,    // }
		0x02, 0x01, 0x02, 0x01,     // ~
	];
}

impl Chargen for SmallFont {
	fn width(c: u8) -> u8 {
		let offset = c - 32;

		let odd = offset & 1 != 0;
		let offset = (offset >> 1) as usize;

		let width = match odd {
			false => Self::FONT_DATA[offset] >> 4,
			true => Self::FONT_DATA[offset] & 0xF
		};

		width
	}

	fn height() -> u8 { 8 }

	fn kerning() -> u8 { 1 }

	fn draw(oled: &mut Oled, c: u8, x: u8, y: u8) -> u8 {
		let mut offset = 48 as usize;

		let width = Self::width(c);

		for c in 32..c {
			offset += Self::width(c) as usize;
		}

		for i in 0..width {
			let b = Self::FONT_DATA[offset];

			for j in 0..8 {
				if b & (1 << j) == 0 { continue }

				oled.set_pixel(x + i, y + j);
			}

			offset += 1;
		}

		width
	}
}

pub struct BigFont {}

impl BigFont {
	const FONT_DATA: &[u8] = &[
		0, 22, 38, 68, 100, 133, 152, 178, 203, 225, 251, // LUT

		/*
		 * Brief explanation of the compression used:
		 * 
		 * Each character is x*20 pixels large, it is stored by column, each one takes up 3 bytes.
		 * The lowest nibble of each column (indicated below with the asterisks) has a special meaning.
		 * If it contains a number other than 0, then the decompression routine will "skip" the next N screen bytes.
		 * If it contains 15, it is treated as the character terminator.
		 * 
		 * Example:
		 * 
		 * // 0             *   1             *   2             *
		 *    0xFF, 0x81, 0x36,                   0x69, 0x42, 0xF0
		 * 
		 * Will get decompressed as:
		 * 
		 * // 0             *   1             *   2             *
		 *    0xFF, 0x81, 0x06, 0x00, 0x00, 0x00, 0x69, 0x42, 0x00
		 */

	//  0             *   1             *   2             *   3             *   4             *   5             *   6             *   7             *   8             *   9             *   10            *   11            *   12            *
		0xF8, 0xFF, 0x01, 0xFC, 0xFF, 0x03, 0xFE, 0xFF, 0x67,                                     0x06, 0x00, 0x66,                                     0xFE, 0xFF, 0x07, 0xFC, 0xFF, 0x03, 0xF8, 0xFF, 0x51,                               0xF0, // 0
		0x00, 0x00, 0x60,                                     0x1C, 0x00, 0x00, 0x1E, 0x00, 0x00, 0xE0, 0xFF, 0x37,                   0xFE, 0xFF, 0xE7,                                                                                     0xF0, // 1
		0x18, 0x00, 0x07, 0x0C, 0x80, 0x01, 0x06, 0xC0, 0x10,       0x60, 0x16,       0x30, 0x00, 0x06, 0x18, 0x10,       0x0C, 0x16,       0x06, 0x00, 0xFE, 0x03, 0x00, 0xFC, 0x01, 0x06, 0xF8, 0x00, 0x56,                               0xF0, // 2
		0x06, 0x80, 0x21,             0x03, 0x80, 0x01, 0x06, 0x46, 0x00, 0x00, 0x20, 0x00, 0x00, 0xF0, 0x01, 0x06, 0x7E, 0x00, 0x00, 0x20, 0x00, 0x00, 0x90, 0xFF, 0x07, 0x0E, 0xFF, 0x03, 0x06, 0xFE, 0x51,                               0xF0, // 3
		0x00, 0x1F, 0x00, 0x80, 0x03, 0x00, 0xC0, 0x01, 0x00, 0xE0, 0x18, 0x00, 0x70, 0x00, 0x00, 0x38, 0x00, 0x00, 0x1C, 0x18, 0x00, 0x0E, 0x00, 0x00, 0xFE, 0xFF, 0x37,                   0xFE, 0xFF, 0x37,                   0x00, 0x18, 0xF0, // 4
		0xFE, 0x81, 0x21,             0x03, 0xFE, 0x01, 0x66,                                     0x86, 0x01, 0x66,                                     0x86, 0xFF, 0x17,       0xFF, 0x03, 0x06, 0xFE, 0x51,                               0xF0, // 5
		0xC0, 0xFF, 0x01, 0xE0, 0xFF, 0x03, 0xF0, 0xFF, 0x07, 0x38, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x8E, 0x01, 0x66,                                     0x86, 0xFF, 0x17,       0xFF, 0x13,       0xFE, 0x51,                               0xF0, // 6
		0x06, 0x00, 0x60,                                     0x06, 0x00, 0x10,       0xF0, 0x17,       0x08, 0x00, 0x06, 0xFC, 0x07, 0x06, 0x0E, 0x00, 0xFE, 0x07, 0x10,       0x02, 0x00, 0xFE, 0x01, 0x50,                               0xF0, // 7
		0xF8, 0xF9, 0x01, 0xFC, 0xFF, 0x03, 0xFE, 0xFF, 0x67,                                     0x06, 0x06, 0x66,                                     0xFE, 0xFF, 0x07, 0xFC, 0xFF, 0x03, 0xF8, 0xF9, 0x51,                               0xF0, // 8
		0xF8, 0x07, 0x00, 0xFC, 0x0F, 0x00, 0xFE, 0x1F, 0x66,                                     0x06, 0x18, 0x17,       0x80, 0x13,       0xC0, 0x01, 0xFE, 0xFF, 0x00, 0xFC, 0x7F, 0x00, 0xF8, 0x1F, 0x50,                               0xF0, // 9
		0xE0, 0x81, 0x37,                   0xE0, 0x81, 0x57,                               0xF0 // :
	];
}

impl Chargen for BigFont {
	fn width(c: u8) -> u8 {
		let c = match c {
			b'0'..=b'9' => c - b'0',
			b':' => 10,
			b' ' => return 7,
			_ => return 0
		};
		
		let mut offset = Self::FONT_DATA[c as usize] as usize + 11;

		let mut width = 0;
		let mut bank = 0;
		let mut skip: u8 = 0;

		while skip != 0x0F {
			if skip > 0 {
				skip = skip.saturating_sub(1);
			} else {
				let b = Self::FONT_DATA[offset];
				offset += 1;

				if bank == 16 {
					skip = b >> 4;
				}
			}

			bank += 8;

			if bank >= 24 {
				bank = 0;
				width += 1;
			}
		}

		width + 2
	}

	fn height() -> u8 { 24 }

	fn kerning() -> u8 { 1 }

	fn draw(oled: &mut Oled, c: u8, x: u8, y: u8) -> u8 {
		let c = match c {
			b'0'..=b'9' => c - b'0',
			b':' => 10,
			b' ' => return 7,
			_ => return 0
		};

		let mut offset = Self::FONT_DATA[c as usize] as usize + 11;

		let mut width = 0;
		let mut bank = 0;
		let mut skip: u8 = 0;

		while skip != 0x0F {
			if skip > 0 {
				skip = skip.saturating_sub(1);
			} else {
				let b = Self::FONT_DATA[offset];
				offset += 1;

				let b = match bank {
					16 => {
						skip = b >> 4;
						b & 0x0F
					},
					_ => b
				};

				for j in 0..8 {
					if b & (1 << j) == 0 { continue }

					for i in 0..3 {
						oled.set_pixel(x + i + width, y + j + bank);
					}
				}
			}

			bank += 8;

			if bank >= 24 {
				bank = 0;
				width += 1;
			}
		}

		width + 2
	}
}

